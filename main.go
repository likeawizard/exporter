package main

import (
	"flag"
	"fmt"
	"github.com/dave/jennifer/jen"
	"os"
	"strings"
)

type arg struct {
	Name string
	Type string
	Op   string
	Qual string
}

type methodWrapper struct {
	Receiver  arg
	Name      string
	Arguments []arg
	Return    []arg
}

var (
	targetType, targetOut, buildTag, outputName, outName string
	replacements                                         []string

	exportTypes     = make([]string, 0)
	exportVariables = make([]string, 0)
	exportConstants = make([]string, 0)
	importsNeeded   = make(map[string]struct{})
	wrappedMethods  = make([]methodWrapper, 0)

	public   = make(map[string]struct{})
	toExport = make(map[string]struct{})
	imports  = make(map[string]string)
)

func main() {
	flag.StringVar(&targetType, "name", "", "target type to export")
	flag.StringVar(&targetOut, "outname", "", "name of exported target")
	flag.StringVar(&outputName, "output", "", "output file name")
	flag.StringVar(&buildTag, "tag", "", "build tag")
	flag.Parse()

	fileName := fmt.Sprintf("%s_export.go", targetType)
	if outputName == "" {
		outputName = fileName
	}

	outName = exportCase(targetType, nil)
	if targetOut != "" {
		outName = targetOut
	}
	replacements = []string{targetType, outName}
	os.Remove(outputName)

	pkg, err := readPackage()
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	collectImports(pkg)
	err = collectTypes(pkg)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	for _, file := range pkg.Syntax {
		if file == nil {
			continue
		}
		walkFile(file)
	}

	output, err := os.Create(outputName)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer output.Close()
	if buildTag != "" {
		output.Write([]byte(fmt.Sprintf("//go:build %s\n\n", buildTag)))
	}

	f := jen.NewFile(pkg.Name)
	f.HeaderComment("Code generated by github.com/likeawizard/exporter. DO NOT EDIT.")

	exportTypes = removeCollisions(exportTypes, public)
	if len(exportTypes) > 0 {
		f.Type().DefsFunc(func(g *jen.Group) {
			for _, t := range exportTypes {
				g.Id(exportCase(t, nil, replacements...)).Op("=").Id(t)
			}
		})
	}

	exportConstants = removeCollisions(exportConstants, public)
	if len(exportConstants) > 0 {
		f.Const().DefsFunc(func(g *jen.Group) {
			for _, c := range exportConstants {
				g.Id(exportCase(c, nil)).Op("=").Id(c)
			}
		})
	}

	exportVariables = removeCollisions(exportVariables, public)
	if len(exportVariables) > 0 {
		f.Var().DefsFunc(func(g *jen.Group) {
			for _, v := range exportVariables {
				g.Id(exportCase(v, nil)).Op("=").Id(v)
			}
		})
	}

	for _, m := range wrappedMethods {
		f.Func().
			Params(jen.Id(m.Receiver.Name).
				Op(m.Receiver.Op).
				Id(exportCase(m.Receiver.Type, nil, replacements...))).
			Id(exportCase(m.Name, nil)).ParamsFunc(func(g *jen.Group) {
			for _, a := range m.Arguments {
				typeToUse := a.Type
				if _, ok := toExport[a.Type]; ok {
					typeToUse = exportCase(a.Type, nil, replacements...)
				}

				g.Id(a.Name).Op(a.Op).Qual(a.Qual, typeToUse)
			}
		}).ParamsFunc(func(g *jen.Group) {
			for _, r := range m.Return {
				g.Id(r.Name).Op(r.Op).Qual(r.Qual, r.Type)
			}
		}).Block(
			jen.Return().Id(m.Receiver.Name).Dot(m.Name).CallFunc(func(g *jen.Group) {
				for _, a := range m.Arguments {
					g.Id(a.Name)
				}
			}),
		)
	}

	err = f.Render(output)
	if err != nil {
		fmt.Println(err)
	}
}

func exportCase(s string, collisions map[string]struct{}, replace ...string) string {
	if len(replace) == 2 && s == replace[0] {
		return replace[1]
	}
	exp := strings.ToUpper(s[:1]) + s[1:]

	if collisions == nil {
		return exp
	}

	if _, ok := collisions[exp]; ok {
		return exp + "Export"
	}

	return exp
}

func removeCollisions(exports []string, collisions map[string]struct{}) []string {
	cleaned := make([]string, 0)
	for _, e := range exports {
		if _, ok := collisions[e]; !ok {
			cleaned = append(cleaned, e)
		}
	}

	return cleaned
}
