package main

import (
	"bufio"
	"fmt"
	"github.com/rs/zerolog/log"
	"golang.org/x/tools/go/packages"
	"os"
	"path/filepath"
	"strings"
)

func readPackage() (*packages.Package, error) {
	loadCfg := &packages.Config{Mode: packages.NeedName | packages.NeedFiles | packages.NeedImports | packages.NeedTypes | packages.NeedSyntax | packages.NeedTypesInfo | packages.NeedTypesSizes}
	pkgs, err := packages.Load(loadCfg)
	if err != nil {
		return nil, err
	}

	// read first line of each file and check if it starts with "// Code generated by" and skip export.
	patterns := make([]string, 0, len(pkgs[0].GoFiles))
	for _, goFile := range pkgs[0].GoFiles {
		f, err := os.Open(goFile)
		if err != nil {
			return nil, err
		}
		s := bufio.NewScanner(f)
		if s.Scan() {
			str := s.Text()
			if !strings.HasPrefix(str, "// Code generated by ") {
				patterns = append(patterns, filepath.Base(goFile))
			} else {
				log.Info().Msgf("Skipping file %q, source is generated", goFile)
			}
		}
		f.Close()
	}
	pkgs, err = packages.Load(loadCfg, patterns...)
	if err != nil {
		return nil, err
	}

	return pkgs[0], nil
}

func collectImports(pkg *packages.Package) map[string]string {
	imports := make(map[string]string)
	for _, imp := range pkg.Imports {
		imports[imp.Name] = imp.PkgPath
	}

	return imports
}

func collectTypes(pkg *packages.Package, cfg Config) (map[string]struct{}, map[string]struct{}, error) {
	toExport := make(map[string]struct{})
	public := make(map[string]struct{})
	names := pkg.Types.Scope().Names()
	for _, n := range names {
		obj := pkg.Types.Scope().Lookup(n)
		if !obj.Exported() {
			toExport[obj.Name()] = struct{}{}
		} else {
			public[obj.Name()] = struct{}{}
		}
	}

	if _, ok := public[cfg.TargetOut]; ok {
		return nil, nil, fmt.Errorf("generated type %q name already exists in package", cfg.TargetOut)
	}

	if _, ok := toExport[cfg.TargetType]; !ok {
		return nil, nil, fmt.Errorf("target type not found in package")
	}

	for k := range toExport {
		if _, ok := public[exportCase(k, nil, cfg.TargetType, cfg.TargetOut)]; ok {
			log.Warn().Str("name", k).Msg("name collision detected, skipping export")
			delete(toExport, k)
		}
	}

	return toExport, public, nil
}
